---
title: User Guide
description: User Guide
layout: ../../layouts/MainLayout.astro
---


This is a **Json Strust** User Guide.

See below for the repository.

* [Json Strust](https://github.com/naotsugu/json-struct)



## Introduction



### What is Json Struct ?

Json Struct is a library for interconversion between JSON and Java objects.

Numerous similar libraries tend to have a high runtime footprint due to heavy use of reflection and excessive functionality.
In many cases, this high footprint is not appropriate if you simply want to perform a simple JSON conversion.

Json Struct has an optimal footprint and speed for simple JSON conversions.
And in most cases, only simple JSON transformations are needed.

Since the annotation processor generates the interconversion code at build time, the output at runtime is a simple object generation/JSON string, providing both excellent footprint and execution speed.


## Quickstart


### Adding Dependencies

Add dependencies and specify annotation processors.

* Gradle Kotlin DSL

```kotlin
dependencies {
  implementation("com.mammb:json-struct:0.3.0")
  annotationProcessor("com.mammb:json-struct:0.3.0")
}
```

* Gradle Groovy DSL

```groovy
dependencies {
    testImplementation 'com.mammb:json-struct:0.3.0'
    annotationProcessor 'com.mammb:json-struct:0.3.0'
}
```

* Maven

```xml
<dependency>
    <groupId>com.mammb</groupId>
    <artifactId>json-struct</artifactId>
    <version>0.3.0</version>
</dependency>
```



### Specify model

Annotate the model to be mapped with the `@JsonStruct` annotation.

```java
@JsonStruct
public record Person(FullName fullName, int age) { }
```

The `@JsonStruct` annotation creates a class dedicated to serialization/deserialization according to the model.


Constructors are used to create objects, and accessor methods are used to generate JSON strings.



### Serialization / Deserialization

Given the following JSON string

```java
var str = """
{
    "fullName": {
        "givenName": "Bob",
        "familyName": "Dylan"
    },
    "age": 81,
    "gender": "MALE"
}
""";
```
Deserialization is performed as follows

```java
var json = Json.of(Person.class);
var person = json.fromJson(str);
```

Serialization is performed as follows

```java
var serialized = json.toJson(person);
```

The creation of Json objects by `Json.of()` has a very small creation cost, so instantiating them each time is not a problem.


Using the Static method, you can also write the following

```java
Person person = Json.objectify(string, Person.class);
String serialized = Json.stringify(person);
```



## @JsonStruct

`@JsonStruct` specifies the model class to be converted to JSON.

Classes to which `@JsonStruct` is assigned will have their JSON conversion codes generated by the annotation processor.

`@JsonStruct` can be assigned to any class, record class, constructor, or static factory method.



### Using record Class

The case for giving `@JsonStruct` to record classes is recommended in many cases.

```java
@JsonStruct
public record Person(FullName fullName, int age) { }
```

The component name of the record class is mapped to the JSON property name.

The target class also functions as an inner class.



### Using class

If `@JsonStruct` is given to a class, the constructor with the highest number of arguments in that class is selected for instantiation.

```java
@JsonStruct
public class Book {
    private final String name;
    public Book(String name) { this.name = name; }
    public String getName() { return name; }
}
```

The constructor argument parameter names are mapped to JSON property names.

An accessor(getter) is used for serialization.
A mutator(setter) is not required.


### Using constructor

If `@JsonStruct` is given to a constructor, that constructor is used for instantiation.

This is an alternative to the case where multiple constructors exist that take the same number of parameters and are given to the class described above.


```java
public class Book {
    private final String name;

    @JsonStruct
    public Book(String name) {
        this.name = name;
    }

    public String getName() { return name; }
}
```


### Using static factory methods

If `@JsonStruct` is given to a static factory method, that static factory method will be used for instantiation.

```java
public class Pet {
    private final String name;
    private Pet(String name) { this.name = name; }

    @JsonStruct
    public static Pet of(String name) {
        return new Pet(name);
    }

    public String getName() { return name; }
}
```

It must be public, static, and return its own class object.



## @JsonStructIgnore

`@JsonStructIgnore` is assigned to items to be ignored in object serialization/deserialization.

By assigning it to a record component of a record class, it will be excluded from serialization/deserialization.

Default values are applied during deserialization.
For the default value, the default value of the language is applied for primitive types.
For objects, it will be null, but for wrapper classes such as Integer, the default value of the primitive type will be applied.


```java
@JsonStruct
public record Person(FullName fullName, @JsonStructIgnore int age) { }
```


In the case of a class, it can be given to the accessor to exclude it from serialization.
If it is given as a constructor argument, the default value will be applied during deserialization.

```java
@JsonStruct
public class Book {
    private final String name;
    // ...
    public Book(String name, // ...) {
        this.name = name;
        // ...
    }

    @JsonStructIgnore
    public String getName() { return name; }
}
```



## @JsonStructConvert

`@JsonStructConvert` is used as follows when you want to customize the default conversion process or define additional conversion processes.


```java
public static final DateTimeFormatter dtFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");

@JsonStructConvert
public static final Function<LocalDateTime, CharSequence> localDateTimeStringify = value ->
    value.format(dtFormatter);

@JsonStructConvert
public static final Function<String, LocalDateTime> localDateTimeObjectify = str ->
    LocalDateTime.parse(str, dtFormatter);
```

This example shows a customized override of the built-in conversion of `LocalDateTime`.

The modifiers and return value signatures of the conversion process must follow the format of the example above.



## Built-in conversion

The following classes provide built-in conversion processing.

* `byte`, `java.lang.Byte`
* `boolean`, `java.lang.Boolean`
* `double`, `java.lang.Double`
* `float`, `java.lang.Float`
* `int`, `java.lang.Integer`
* `long`, `java.lang.Long`
* `short`, `java.lang.Short`
* `java.math.BigDecimal`
* `java.lang.Number`
* `java.math.BigInteger`
* `java.util.OptionalDouble`
* `java.util.OptionalInt`
* `java.util.OptionalLong`

* `java.lang.String`
* `char`, `java.lang.Character`
* `java.util.Date`
* `java.util.Calendar`
* `java.util.TimeZone`
* `java.time.Instant`
* `java.time.LocalDateTime`
* `java.time.LocalDate`
* `java.time.LocalTime`
* `java.time.OffsetDateTime`
* `java.time.OffsetTime`
* `java.time.ZonedDateTime`
* `java.time.ZoneId`
* `java.time.ZoneOffset`
* `java.time.Duration`
* `java.nio.file.Path`
* `java.time.Period`
* `java.net.URI`
* `java.net.URL`
* `java.util.UUID`


`java.sql.Date`, `java.sql.Timestamp` do not provide built-in conversion handling


## JsonPrettyWriter

To get a formatted Json, use `JsonPrettyWriter` as follows

```java
var bob = new Person(new FullName("Bob", "Dylan"), 81, Gender.FEMALE);
var writer = new StringWriter();
Json.stringify(bob, JsonPrettyWriter.of(writer));
```

The output would be as follows

```java
assertEquals("""
    {
      "fullName": {
        "givenName": "Bob",
        "familyName": "Dylan"
      },
      "age": 81,
      "gender": "FEMALE"
    }""", writer.toString());
```

You can also format Json strings directly.

```java
var ret = JsonPrettyWriter.toPrettyString("""
    {"fullName":{"givenName":"Bob","familyName":"Dylan"},"age": 81,"gender": "FEMALE"}""");
```

